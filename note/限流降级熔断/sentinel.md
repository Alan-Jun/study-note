# 官方杰嫂文档

https://sentinelguard.io/zh-cn/docs/introduction.html

## 他的核心功能

sentinel的核心功能流量控制，熔断降级等等，都依赖它的数据统计（资源的流量，线程数，rt, 异常数...）,在sentinel中是使用[滑动窗口算法](#滑动窗口算法)来完成资源设置的时间窗口内的数据统计的

## 流量控制

流量控制又叫做过载保护，sentinel提供下面几种能力，功能详情可以在上文链接的官网中查看这里就不重复了，主要想聊聊他提供的功能使用到的算法：

* 匀速器：漏桶算法
* 冷启动：
* 直接拒绝：不需要使用算法，根据获取的统计数据直接和陪孩子的规则做对比即刻

## 熔断降级



## 系统负载保护



# 算法解释

## 滑动窗口算法

滑动窗口算法的全称叫做滑动时间窗口算法，它是为了解决[计数器算法](#计数器算法)的临界值的问题出现的，比如：在TCP的网络通信协议中就是用到了该算法来解决网络拥堵问题。

滑动时间窗口算法在计数器算法的基础上做了优化，他将计数的区间分成了多个小窗口，每次大窗口向后滑动一个小窗口，并且保证大窗口内的流量不超出阈值，这样的实现相对计数器算法来说平滑了很多，窗口拆分得细一些也能一定程度的保证达成我们需要的效果，但是并没有完全解决时间零界点的问题，比如1分钟拆分成了10个100ms的小窗口，在窗口未滑动的时候，1s 20ms 的时候了2000的流量，而我们的限制是，1分钟1000。所以问题还是存在的，不过由于窗口拆分是可以拆分得更细一些的，所以相比计数器算法要平滑很多，大多数业务场景下能达成效果。

上代码：

```java

```

该算法还有一种实现方式，本质思想是转换概念，将原本问题的通过确定时间范围去进行次数限制。转换成线确定次数大小，然后再来进行时间限制。这种方式由于需要记录每一次请求的time 实现起来会更费内存一些，而上面一种实现方式消耗更多的是拆分的窗口数量的内存

https://cloud.tencent.com/developer/article/1761700

## 计数器算法

计数器算法是我们限流算法中最简单也是最容易实现的算法。比如我们要限制1分钟内调用不超过1000次，我们可以这样设计，定义2个变量，一个是访问次数count，一个是记录访问次数计算的开始时间startTime，如果记录时间和当前时间比较大于1分钟，则重新计时(startTime = currentTime)，如果在一分钟以内，我们把访问次数加一(count++)。

上代码：

```java
private volatile long startTime;
private volatile int count;
private static final long duringTime = 60 * 1000L ;
private static final int limit = 1000L ;

public boolean canExecute(){
  long currentTime = System.currentTimeMills();
  if(currentTime - duringTime >= startTime){
    	count = 0;
      startTime = currentTime;
    	reture true;
  }
  count++
	if(count > limit){
    return false;
  }
  return true;
}
```

**它的缺点：**简单易于实现确实很不错，不过也存在着一个明显的缺点：“时间零界点”问题，比如在 0-58秒的时候都没有收到请求，然后到了59秒的时候来了500个请求，然后下一个一分钟的开始的一秒又来了500个请求，这种场景就明显不符合我们一分钟内限流1000的要求了，因为这种情况很可能导致我们的系统崩溃（我们限流的设置是为了保护系统的处理能力是在它的承载范围之内）