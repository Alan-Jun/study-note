# 分布式环境有哪些特点，带来了哪些问题

分布式的特点：分布性、对等性、并发性、缺乏全局时钟、故障总会发生
分布式环境下的各种问题：通讯异常、网络分区、成功失败超时三态、节点故障

# 分布式场景下的一致性

需要了解 CAP, BASE

# 分布式事务部分解决方案

## 强一致性

### 协议介绍

https://cloud.tencent.com/developer/article/1793276

#### 两阶段提交协议

两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）

https://zhuanlan.zhihu.com/p/565715654

#### 三阶段提交协议

https://baijiahao.baidu.com/s?id=1711892150916363977&wfr=spider&for=pc

针对多数据库事务可以使用居于XA协议的事务解决方案：采用spring 3.0以及以上版本 + Atomikos/ + JTA进行支持 （XA协议的支持，XA就是一种2pc协议）；

> 在Java中，分布式事务主要的规范是JTA/XA。其中：JTA是Java的事务管理器规范，XA是工业标准的X/Open CAE规范，可被两阶段提交及回滚的事务资源定义。比如某数据库实现了XA规范，则不管是JTA，还是MSDTC，都可以基于同样的行为对该数据库进行事务处理。**XA协议是目前支持最广泛的一个协议**
>
> JTA全称为Java Transaction API，顾名思义JTA定义了一组统一的事务编程的接口，这些接口如下：
>
> `XAResource`：XAResource接口是对实现了X/Open CAE规范的资源管理器 (Resource Manager，数据库就是典型的资源管理器) 的抽象，它由资源适配器 (Resource Apdater) 提供实现。`XAResource`是支持事务控制的核心。
> `Transaction`：`Transaction`接口是一个事务实例的抽象，通过它可以控制事务内多个资源的提交或者回滚。二阶段提交过程也是由`Transaction`接口的实现者来完成的。
> `TransactionManager`：托管模式 (managed mode) 下，`TransactionManager`接口是被应用服务器调用，以控制事务的边界的。
> `UserTransaction`：非托管模式 (non-managed mode) 下，应用程序可以通过`UserTransaction`接口控制事务的边界
>
> 在tomcat下是没有分布式事务的，可以借助于第三方Jotm和Automikos实现，在spring中分布式事务是通过jta（jotm，atomikos，）来进行实现。即：通过代码的方式来决定是否是分布式事务。
>
> 这里我们引用以下spring 官方网站的说明
>
> ![image-20200716170457227](assets/image-20200716170457227.png)
>
> 关于JTA的实现的框架有：他们都实现了TM管理多数据源事务的功能
>
> * Atomikos
>   大家推荐最多的。和JOTM相比Atomikos Transactions Essentials更加稳定，它原来是商业项目，现在开源了。象MySQL一样卖服务支持的。而且论坛页比较活跃，有问题很快可以解决。
> * JOTM
>
> * GeronimoTM/Jencks 官方文档比较少，不适合学习和维护。
> * JBossTS 是一个应用在JBOSS服务器上的，肯定是一个成熟的产品，也有好的支持，详细信息可以看这里：http://www.theserverside.com/news/thread.tss?thread_id=37941
> * Bitronix ：它是一个完全工作的XA事务管理器，提供JTA API所需的所有服务，同时尽量使代码简单，以便更容易地理解XA语义。 目前在github 上的stars 还比较少
>
> 等等

**注意：该方案无法解决服务间调用的分布式事务问题**

* 优点：严格的ACID,相对其他数据关联性高的数据的分布式事务实现，相对简单（因为spring JTA +Atomikos 可以极低的业务代码侵入性 帮你解决多资源的事务管理）
* 缺点：
  * 实现复杂（对于使用成熟框架的人来说其实不复杂，但是对于开发这些框架的人来说确实是它的API是比较复杂的）
  * 同步阻塞：事务执行过程中，所有参与节点都是事务阻塞的。当参与者占有资源时，其他访问相关资源的进程也将处于阻塞状态。 参与者对锁资源的释放必须等到事务结束，所以与一阶段提交相比，执行同样的事务，二阶段会耗费更多时间（连接资源也会占用更长时间）。 事务执行时间的延长意味着锁资源发生冲突的概率增加，当事务并发量达到一定数量时，会出现大量事务积压甚至出现死锁，系统性能会严重下滑。

> 更多关于 XA 协议的 https://zhuanlan.zhihu.com/p/38197629
>
> JTA 规范 http://www.tianshouzhi.com/api/tutorials/distributed_transaction/385
>
> 大体的故障恢复策略 和上面连接中讲的大差不差的 JTA 规范中也是有故障恢复的



### 基于LCN

在分析优缺点前我们需要看一下：[lcn的事务控制原理](#lcn的事务控制原理)

* 优点：
  * 业务代码侵入性低
  * 该模式下的事务提交与回滚是由本地事务方控制，对于数据一致性上有较高的保障。
* 缺点：缺陷在于代理的连接需要随事务发起方一同释放连接，增加了数据库连接资源占用的时间。（和2pc的这方面缺点差不多）

#### 基于TCC模式

在分析优缺点前我们可以看一下：[lcn的事务控制原理](#lcn的事务控制原理)

* 优点：
  * 有无本地事务控制都可以支持，所以其使用面更广一些
* 缺点
  * 该模式对代码的嵌入性高，要求每个业务需要写三种步骤（try, comfirm, cancel）的操作。（实现复杂）
  * 数据一致性控制几乎完全由开发者控制，对业务开发难度更高。

#### 基于TXC模式的处理

在分析优缺点前我们需要看一下：[lcn的事务控制原理](#lcn的事务控制原理)

逆向sql的方式：实现原理是在执行SQL之前，先查询SQL的影响数据，然后保存执行的SQL快照信息和创建锁（为了在分布式层面实现事务隔离性）。当需要回滚的时候就采用这些记录数据回滚数据库，目前锁实现依赖redis分布式锁控制。

* 优点
  * 业务代码侵入性低
  * 不会占用数据库的连接资源
* 缺点：
  * 仅限于对支持SQL方式的模块支持（局限性较大）
  * 由于每次执行SQL之前需要先查询影响数据，因此相比LCN模式消耗资源与时间要多

**[tx-lcn](https://github.com/codingapi/tx-lcn)** 框架实现了 从最初的 LCN 模式，TCC 事务的支持 

#### lcn的事务控制原理

 ![image-20200716162551391](assets/image-20200716162551391.png)

**核心步骤**

- 创建事务组
  是指在事务发起方开始执行业务代码之前先调用TxManager创建事务组对象，然后拿到事务标示GroupId的过程。
- 加入事务组
  添加事务组是指参与方在执行完业务方法以后，将该模块的事务信息通知给TxManager的操作。
- 通知事务组
  是指在发起方执行完业务代码以后，将发起方执行结果状态通知给TxManager,TxManager将根据事务最终状态和事务组的信息来通知相应的参与模块提交或回滚事务，并返回结果给事务发起方。

上面的整个过程其实会存在很多问题，主要的难处理的问题存在过程4通知事务组之后的流程，我们先看一下之前的流程吧，在这部分流程中，不管是事务发起者异常，还是说参与方A,B,发生异常，还是执行过程超时都不会引发什么问题，为什么呢? 

1. 事务发起者异常，直接回滚这个就不讨论了
2. 其次参与方异常，处理可以是通过事务发起者捕获到参与者异常来进行`TM`回滚，这种方式可以通过TM通知参与者回滚，如果网络原因造成信息丢失（发送给参与者的回滚信息丢失；还是说参与者回执给TM的操作完成情况信息丢失都可以通过重试来解决，**注意：存在重试的话，方法实现就要保证幂等**），当然这里采用的一种方式是，某一个产生异常的参与者发生异常就不加入事务组，这样在回滚的时候，就不需要TM去操作这个异常的参与者的回滚了（异常的参与者的操作应该在其内部一场的时候就没成功/自动回滚了的），可以减小一些开销。说到这里，相信你也知道了它的流程时序图中为什么不是参与者先加入事务组在执行业务操作了，而是先执行业务操作，最后在决定是否加入事务组。

3. 参与者执行超时，相信在微服务间调用这个是肯定需要处理的问题了，通常服务间接口调用我们会设置超时时间，如果参与者发生超时，可以当作是异常处理，发起回滚处理

   * 这时候参与者如果在TM收到执行回滚操作前

     * 参与者发生异常，什么都不用做；
     * 如果参与者执行完了，调用加入事务组的方法，那么TM可以把它加入到事务组，然后接收到回滚操作通知，正常执行回滚就可以了；

     * 如果参与者没有发生异常还在超时处理业务逻辑中，那么不需要采取任何操作，因为TM这时候也发现不了参与者；

   * 如果在执行回滚操作期间

     * 参与者发生异常，什么都不用做；

     * 如果参与者要加入事务组，那么可以直接回滚该事务，不用加入事务组了；

     * 如果参与者没有发生异常还在超时处理业务逻辑中，那么不需要采取任何操作，因为TM这时候也发现不了参与者。

最麻烦的问题存在于我们通知事务提交的过程，这个过程可能存在什么情况呢？

1. 在直接执行的时候，某一个参与者返回提交失败了，那么我们肯定需要，去回滚其他参与者的事务了，TCC模式只要调用 cancel 方法就好了（**注意我们的confirm,cancel需要做幂等实现**），TXC模式也能满足需求（在我看来TXC模式是对支持sql访问的数据库的TCC的低侵入性实现，不过目前该框架还不是很完善，这种功能不是很建议使用），LCN模式是否满足我还不太清楚（正在详细了解这个框架中）。

2. 还有一个问题就是我们的事务协调者 TM的单点问题，以及故障恢复问题，这个都可以参考2pc的故障恢复，基于WAL(先写日志)的方式来做故障恢复

> 参考：
>
> * https://houbb.github.io/2018/09/02/api-jta
>
> * [tx-lcn](https://github.com/codingapi/tx-lcn)

### Seat分布式事务框架

https://github.com/seata/seata

中文文档：

1. https://github.com/seata/seata/wiki/%E6%A6%82%E8%A7%88
2. http://seata.io/zh-cn/docs/overview/what-is-seata.html

基于两阶段提交实现的

### Saga 模式

https://baijiahao.baidu.com/s?id=1709259416203967205&wfr=spider&for=pc

### 基于可靠消息的最终一致性方案

其实这种方案是用mq来帮助我们协调，但是要使用MQ来协调就需要选择MQ提供的可靠性最强的模式，保证消息不丢，但是要涉及到协调，那么会有下面的情况

1. 那就会有反查操作是否成功，如果操作失败可以再发一个消息队列去处理回滚操作，然后你会发现你还得去反查是否会滚成功，陷入的死循环
2. **做最终一致性， 反查失败的补偿，补偿失败的告警然后协调开发同学解决问题，大多数情况是不会发生的，发生这种情况是小概率事件，人工补偿就好**