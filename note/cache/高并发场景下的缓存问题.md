# 缓存冷热数据分离问题

设置缓存有效期，经常访问的热数据自然会在缓存中，同时对访问过的数据进行延期（还能提升），这样冷数据自然就和热数据分离了

# 缓存一致性问题

[缓存一致性问题](缓存一致性问题.md)

# 缓存穿透问题

* 什么是**缓存穿透**？解决方案？

  答：查询一个数据库和缓存中都完全不存在的值，穿透了我们缓存和db，同时这种不存在的数据在db的查询中性能也是极低的，通常是外部的黑客攻击造成的，会将你的db完全打死

  解决方案：

  1. 对这样的数据做空缓存（缓存时间设置短一些），存在一个问题如果黑客在同时使用大量的不存在的数据来做请求，那么在做空缓存前是需要去查询db的，还是会造成问题，这就需要下面的过滤器的方案

  2. 对请求进行过滤  

     * 普通过滤器

       某些业务场景，比如机票查询，需要用到出发城市到达城市，如果你传一个不存在的城市，这就会造成缓存穿透，然后我们当前的场景，中国总共才600多个城市，有机场的更是没有多少，由于数据量少，过滤逻辑简单那么我们就可以简单的使用城市的code来做一个map简单过滤器。map中查询不到的就直接返回

     * bitmap/roaringBitmap  

       > [bitmap&roaringBitMap](../algorithm/bitmap&roaringBitMap.md)

     * 布隆过滤器

       https://zhuanlan.zhihu.com/p/43263751

       https://cloud.tencent.com/developer/article/1136056

# 缓存过期

## 缓存击穿问题

* 什么是**缓存击穿**？解决方案？

  答：高并发情况下，查询时候一部分缓存刚好过期了，这个和雪崩有那么一些类似。区别就是雪崩是大量缓存同时失效

  解决方案：在设置缓存过期时间的时候，增加一个随机变量让缓存的时间尽量分散

## 缓存雪崩问题

* 什么是**缓存雪崩**？解决方案？

  答：大批量缓存在同一时间失效

  解决方案：

  ​	**系统第一次启动的时候可以使用缓存预热**

  1. 可以通过观察用户行为,合理设置缓存时间，**这个在分布式情况下代码实现比较麻烦,不推荐**
  2. 缓存预加载，针对热点数据在缓存快要失效前，做一次预加载（实现方式可以是在一次访问缓存的时候检查到缓存快要过期的时候，使用新的线程去做一次缓存刷新）

  **不推荐使用缓存永不过期，太消耗系统内存了，在数据量的不断增长而不失效，可能给系统带来内存负载问题**

**热点数据集中失效**

# 突发性的热点数据缓存重建问题

在一些电商场景中，可能一个不怎么火的商品突然因为一个媒体事件/人们主播的直播间推荐突然就热了，这时候如果网站一下涌入大量的用户来查询这时候问题就出现了，冷数据是没有缓存的，这时候并发的都会请求到d b,这就可能造成严重的系统问题

这种问题怎么处理呢？

1. 如果是直播间推荐的场景还可以和主动预热（推广活动是可以提前预知的）

2. 不是上面这种可以提前预知的场景（作为一个电商系统这种场景必须考虑），可以使用在查询db的时候使用商品的唯一key使用分布式锁（因为是针对相同商品查询锁，并且获取到数据放入缓存之后后续查询都是走缓存，所以不会影响什么性能），同时借鉴单例模式的double check 的方式来完成，伪代码

   ```
   // 第一次查询缓存
   cache = getCache(key);
   if(cache != null){
      return cache;
   }
   //使用redis实现分布式锁，获取锁
   if(redisLock.acquire（key,timeOut)){
   	// 第二次获取缓存
   	cache = getCache(key);
   	if(cache != null){
      return cache;
   	}
   	// 查询db
   	date = DateDao.getdate(key);
   	return date;
   }
   return null;
   
   ```

