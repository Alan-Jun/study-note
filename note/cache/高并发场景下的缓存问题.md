# 缓存冷热数据分离问题

1. 设置缓存有效期，经常访问的热数据自然会在缓存中，同时对访问过的数据进行延期（还能提升热点数据的命中率），这样冷数据自然就和热数据分离了
2. 结合Redis 端设置LRU的淘汰策略，可以在内存不够的时候保证热点数据的命中率

# 缓存一致性问题

[缓存一致性问题](缓存一致性问题.md)

# 缓存穿透问题

* 什么是**缓存穿透**？解决方案？

  答：查询一个数据库和缓存中都完全不存在的值，穿透了我们缓存和db，同时这种不存在的数据在db的查询中性能也是极低的，通常是外部的黑客攻击造成的，会将你的db完全打死

  解决方案：

  1. 对这样的数据做空缓存 (不常用，黑客攻击你，光使用这个是没用的)

     解决方案：

     1. **这就需要下面的过滤器的方案**
     2. **除此之外和使用DCL(双重检查+锁)来实现控制并发，如果被攻击的时候就算他来了也得先去排队，获取到锁的去查一次db发现没有，给做一个空缓存加到缓存中，释放锁，其他线程这时候来再查一次缓存发现有数据了直接返回**
  
  2. 对请求进行过滤  
  
     * 普通过滤器
  
       某些业务场景，比如机票查询，需要用到出发城市到达城市，如果你传一个不存在的城市，这就会造成缓存穿透，然后我们当前的场景，中国总共才600多个城市，有机场的更是没有多少，由于数据量少，过滤逻辑简单那么我们就可以简单的使用城市的code来做一个map简单过滤器。map中查询不到的就直接返回
  
     * bitmap/roaringBitmap  
  
       > [bitmap&roaringBitMap](../algorithm/bitmap&roaringBitMap.md)
  
     * 布隆过滤器
  
       https://zhuanlan.zhihu.com/p/43263751
  
       https://cloud.tencent.com/developer/article/1136056
  
  **大流量的场景记住一定要对访问db的查询处做限流降级，因为db出问题，可能会影响到使用该DB的很多业务场景，造成大量业务场景的故障，影响面太大。**

# 缓存击穿

缓存击穿是指当缓存中某个热点数据过期了，在该热点数据重新载入缓存之前，有大量的查询请求穿过缓存，直接查询数据库。这种情况会导致数据库压力瞬间骤增，造成大量请求阻塞，甚至直接挂掉。

可以采用 [突发性的热点数据缓存重建问题](#突发性的热点数据缓存重建问题) 相同的方式  DCL (double check lock)

# 缓存雪崩问题

什么是**缓存雪崩**？解决方案？

答：**大量热点数据集中失效**

**解决方案：**

​	**系统第一次启动的时候做缓存预热**

1. 在设置缓存时间的时候使用一个较大的离散随机数，保证缓存尽量不在一个时间失效。
2. 定时更新策略
3. 双层缓存策略C1为短期，C2为长期

**大流量的场景记住一定要对访问db的查询处做限流降级，因为db出问题，可能会影响到使用该DB的很多业务场景，造成大量业务场景的故障，影响面太大。**

# 突发性的热点数据缓存重建问题

在一些电商场景中，可能一个不怎么火的商品突然因为一个媒体事件/人们主播的直播间推荐突然就热了，这时候如果网站一下涌入大量的用户来查询这时候问题就出现了，冷数据是没有缓存的，这时候并发的都会请求到d b,这就可能造成严重的系统问题

这种问题怎么处理呢？

1. 如果是直播间推荐的场景还可以和主动预热（推广活动是可以提前预知的）

2. 不是上面这种可以提前预知的场景（作为一个电商系统这种场景必须考虑），可以使用在查询db的时候使用商品的唯一key使用分布式锁（因为是针对相同商品查询锁，并且获取到数据放入缓存之后后续查询都是走缓存，所以不会影响什么性能），同时借鉴单例模式的DCL（double check lock） 的方式来完成，伪代码

   ```
   // 第一次查询缓存
   cache = getCache(key);
   if(cache != null){
      return cache;
   }
   //使用redis实现分布式锁，获取锁
   if(redisLock.acquire（key,timeOut)){
   	// 第二次获取缓存
   	cache = getCache(key);
   	if(cache != null){
      return cache;
   	}
   	// 查询db
   	date = DateDao.getdate(key);
   	return date;
   }
   return null;
   
   ```

