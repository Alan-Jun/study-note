# FIFO

first in first out (也就是**先进先出**队列)，这是最简单，最公平的一种模式，达到上限后，队列前面的淘汰掉

# LRU

The Least Recently Used，**最近最久未使用**算法,该算法在很多分布式系统中都有使用（redis,memcached）

LRU算法的思想是：**一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）**。

该算法的实现 可以参考java中LinkedHashMap[详见这篇文章的LinkedHashMap这一节](../java/java集合/Java集合框架.md#LinkedHashMap)的来理解

# LFU

Least Frequently Used ，最近最少使用算法

LFU算法的思想是：**如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰**。

算法 ：

* hash表 + 有序链表的结构

  * hash表 : 用来快速找到对应的数据节点 （cache 查询数据肯定要高效）

  * 有序双向链表： 用于排序，以及方便淘汰数据
    * 如果是从小到达的排序，那么需要淘汰数据的时候从头被淘汰即可
    * 一个被访问过的数据他的权重加1，然后向后找到自己的在链表中位置即可
  * 优点：在数据访问符合正态分布时，相比于LRU算法，LFU算法的缓存命中率会高一些。
  * 缺点：
    * LFU的复杂度要比LRU更高一些。
    * 需要维护数据的访问频次，每次访问都需要更新。
    * 早期的数据相比于后期的数据更容易被缓存下来，导致后期的数据（新加入的缓存）很难被缓存。比如：是当缓存满了之后，新来的数据由于访问次数少，很容易被删除掉

* hash 表（快速访问数据） +  访问次数的hash表（数据根据访问此时存放在以 访问次数wei key， value: 双端链表的数据结构中） +双端链表 。

  * hash表 : 用来快速找到对应的数据节点 （cache 查询数据肯定要高效）
  * 访问次数的hash表：数据根据访问此时存放在以 访问次数wei key， value: 双端链表的数据结构中
  * 双端链表 : 祖宗为 访问次数的hash表的 value值。

  **相比上一个算法多了一个 访问次数的hash表 可以优化数据移动的事件复杂度，缺点就是增加了空间复杂度, 不过 LFU算法的缺点还是没有解决**

**LFU算法优化**

* 更加紧凑的数据结构，避免维护访问频次的高消耗。
* 避免早期的热点数据一直占据缓存，即LFU算法也需有一些访问时间模式的特性。
  * 可以在排序的时候先根据访问，如果访问次数相同那么使用 时间来排序最近访问的放在更后面。
* 消除缓存末端的抖动。

> https://juejin.cn/post/6844904053000912903