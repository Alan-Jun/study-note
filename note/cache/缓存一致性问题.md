# 缓存一致性问题

我们只要使用缓存就会涉及到缓存和数据库双存储双写，只要涉及到双写，就会有数据一致性问题（**缓存可以丢，但是不能错，数据库操作是核心，不能因为缓存的操作影响数据库的操作**）

**典型的缓存+数据库的读写模式是**

* 读的时候：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存
* 数据更新的时候：先更新数据库，然后再删除缓存

这里为什么不是先更新数据库然后重新set缓存呢？我们来看一下，如果该数据不是热数据，更新频率，比查询频率要高的话，比如1分钟更新了10次，但是就查询了一次，如果我们更新数据的逻辑是先更新数据库，再跟新缓存，那就相当于我们要跟更新10次缓存，但是就查询了一次，实际上如果只是删除缓存的话，那么在这一分钟内，该数据只被访问一次（查一次DB,set一次缓存），开销大幅度降低，其实这样的设计就是一种lazy计算的思想（懒加载）。**如果需要更高的缓存命中那么请使用set,而不是删除**

**这也是我选择的方式，其实这个问题现在存在争论，下面我们会讨论这个问题**

# 争论

**先更新数据库 再删除缓存会有什么问题**，如果我们数据库修改失败，那就什么都不做，这个没问题，但是数据库修改成功，在删除缓存，首先是更新成功后删除缓存，删除这个过程是需要时间的，那么这个时间段内就可能产生脏读，其次是一个极端的情况，就是由于网络问题或则其他问题导致缓存删除失败，那么这个脏读在我们设置的缓存时间内（不存在再次更新数据的情况），都是脏的。

网上很多提出了解决方案就是**先删除缓存，再修改数据库**，这样的话，删除缓存失败那就直接结束，成功接着操作数据库，数据库失败或成功，都对我们的数据一致性没有影响。但是我们来看删除缓存到更新数据库也是存在时差的，高并发的情况下还是可能产生，先删除了缓存，数据库未更改的时候，这时候一个请求过来了，缓存不存在，查数据库，使用查询到的修改前的旧数据，刷新了缓存，随后数据修改成功，那么这时候的缓存数据就是不一致的。**更加核心的问题是，缓存的操作成功与否居然会影响我的数据库的操作，我想这个在业务上是不允许的，因为数据库是核心关键，缓存只是一个辅助，比如扣减库存，你不能说缓存操作失败了，那我扣减库存不做，返回个失败吧，有人就要说了，那么我删除缓存，这个操作失败与否，不影响我更新数据库，那么我们来看如果操作失败不影响更新数据库，那不一样存在脏读吗，你说我们操作数据库之后再删除一次，这样缓存就不脏了，但是你第一次都失败了更新数据库之后再删除就能保证成功了？就算第一次成功了，第二次也成功了，操作两次耗时和 操作一次的耗时哪个性价比高？怎么都可能存在缓存不一致的情况的，那为什么不采取 先更新数据库再 删除缓存/set缓存的操作呢**，所以我个人觉得先删除库存 在更新DB，在删除/set缓存是不可取的。高并发情况下都一定会有一致性问题，**所以经典范式 先更新DB,再操作缓存确实是经典范式**

其中先更新数据库在set缓存会存在 并发造成脏数据问题，在并发现很明显，所以除非是业务上不存在并发可以使用它提高缓存命中之外，其他情况使用 更新数据库 在 del缓存时比较好的保证缓存一致性的方案

如果缓存真的操作失败是网络不通，可以catch 处理，人工介入了，