# 缓存一致性问题

我们只要使用缓存就会涉及到缓存和数据库双存储双写，只要涉及到双写，就会有数据一致性问题（**缓存可以丢，但是不能错，数据库操作是核心，不能因为缓存的操作影响数据库的操作**）

**典型的缓存+数据库的读写模式是 这里我们叫做 方案1**

* 读的时候：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存
* 数据更新的时候：先更新数据库，然后再set缓存

**这种方式存在什么问题呢？**

比如我们存在一个查询小明的钱包余额的场景，此时：数据库中存了小明有10块钱，在并发场景下，

A:小张给小明转了100块钱，此时小明应该是有110块钱，

B:同一时间来了一个查询余额的请求，但是由于是并发的，B操作的db操作可能还未提交，同时由于我们DB查询通常是不会设置串行化这个隔离界别的（性能极差），所以读写是不会互斥的，此时查询到的就是10块钱这个数据

然后 A 操作完成去set 了 缓存是110，然而B操作拿到的是10，又去讲缓存设置成了10，数据就不一致了

**怎们解决这个问题呢？**

网上我看到很多方案：

* 在方案一的基础上 ，更新db后set缓存，延迟再次set一次； 这里我们叫方案2吧 

  这个方案是希望实现最终一致性，但是方案存在两个核心问题

  1. 延迟多久，延迟太短可能还是会发生方案1的问题，但是延迟太长也不太好因为这样出现不一致了之后中间的这个不一致的时间窗口太长，显然不是最优；
  2. 如果在延迟操作的过程中服务出现了问题比如donw机了这个数据在下一次更新（使用缓存的场景大多都是读多写少的，下一次更新可能间隔比较长），或者缓存有效期内就一致是错的

* 针对方案二的问题，于是我们就想到了消息，比如依靠可靠性比较高的消息来完成这个延迟操作（比如rocket的事务消息）；当然除此之外更好的是监听binlog的消息来处理，然后我们收到消息之后重新去查询一次DB获取最新的数据来更新缓存

**当然也可以在更新DB之后 删除缓存，但是删除缓存的方案的最大问题是，会降低缓存命中率，这个方案也是需要消息延迟来实现最终一致性的** 