# 缓存一致性问题

我们只要使用缓存就会涉及到缓存和数据库双存储双写，只要涉及到双写，就会有数据一致性问题（**缓存可以丢，但是不能错，数据库操作是核心，不能因为缓存的操作影响数据库的操作**）

**典型的缓存+数据库的读写模式是 这里我们叫做 方案1**

* 读的时候：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存
* 数据更新的时候：先更新数据库，然后再set缓存

**这种方式存在什么问题呢？**

比如我们存在一个查询小明的钱包余额的场景，此时：数据库中存了小明有10块钱，在并发场景下，

A:小张给小明转了100块钱，此时小明应该是有110块钱，

B:同一时间来了一个查询余额的请求，但是由于是并发的，B操作的db操作可能还未提交，同时由于我们DB查询通常是不会设置串行化这个隔离界别的（性能极差），所以读写是不会互斥的，此时查询到的就是10块钱这个数据

然后 A 操作完成去set 了 缓存是110，然而B操作拿到的是10，又去将缓存设置成了10，数据就不一致了

**怎们解决这个问题呢？**

网上我看到很多方案：

* 在方案一的基础上 ，更新db后set缓存，延迟再次set一次； 这里我们叫方案2吧 

  这个方案是希望实现最终一致性，但是方案存在两个核心问题

  1. 延迟多久，延迟太短可能还是会发生方案1的问题，但是延迟太长也不太好因为这样出现不一致了之后中间的这个不一致的时间窗口太长，显然不是最优；
  2. 如果在延迟操作的过程中服务出现了问题比如down机了，这个数据在下一次更新前的缓存有效期内就一直是错的数据

* 针对方案二的问题，于是我们就想到了消息，比如依靠可靠性比较高的消息来完成这个延迟操作（比如rocket的事务消息）；当然除此之外更好的是监听binlog的消息来处理，然后我们收到消息之后重新去查询一次DB获取最新的数据来更新缓存

**当然也可以在更新DB之后 删除缓存，但是删除缓存的方案的最大问题是，会降低缓存命中率，然后删除也无法完全解决一致性问题，这个方案也是需要消息延迟来实现最终一致性的** 



这篇文章也可看看 https://mp.weixin.qq.com/s/dYvM8_6SQnYRB6KjPsprbw

## 删除缓存和设置缓存的区别

**区别一：**

我们以**先更新数据库，再删除缓存**来举例。

如果是更新的话，那就是**先更新数据库，再更新缓存**。

举个例子：如果数据库1小时内更新了1000次，那么缓存也要更新1000次，但是这个缓存可能在1小时内只被读取了1次，那么这1000次的更新有必要吗？

反过来，如果是删除的话，就算数据库更新了1000次，那么也只是做了1次缓存删除（和redis 的io交互次数是一定的，区别是请求到了redis 之后 redis 判断没有缓存，有才执行内存删除操作）

**区别二：**

删除缓存有一个问题是，会导致请求穿透缓存命中db, 如果是一个热点key,那就会有很多请求击穿到db了，这样缓存命中率降低了；**当然我们可以通过DCL（double check lock） 来避免这个击穿问题**

set 的话不会存在缓存命中率低的问题，也不会存在热点key 穿透次数增加的问题，但是大多数时候其实事不值得的

# 建议选择删除

删除缓存发生的数据不一致的概率会低很多，如果缓存数据是一个复杂类型，需要先查询再修改的操作，当然也可以在内存中构建好数据直接set替换，但是实现起来就要复杂很多, 删除就要简单得多，虽然删除会导致cache miss 但是可以用过我们说过的加锁DCL（double check lock） 来处理。

ps: 如果你的业务场景不涉及到缓存的状态来回变更的场景，缓存数据的生命周期是 创建，失效 ，那么直接用set 会更好

# DCL

```
// 第一次查询缓存
cache = getCache(key);
if(cache != null){
   return cache;
}
//使用redis实现分布式锁，获取锁
if(redisLock.acquire（key,timeOut)){
	// 第二次获取缓存
	cache = getCache(key);
	if(cache != null){
   return cache;
	}
	// 查询db
	date = DateDao.getdate(key);
	return date;
}
return null;

```

