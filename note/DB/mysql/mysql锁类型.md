# mysql的锁

* **它是用于管理不同事务对共享资源的并发访问**
* **表锁**
  * 意向共享锁 Intention Shared Locks （简称 IS 锁，属于表锁）
  * 意向排他锁 Intention Exclusive Locks （简称 IX 锁，属于表锁）
* **行锁**
  * 共享锁 Shared Locks  （简称 S 锁，属于行锁）
  * 排他锁 Exclusive Locks（简称 X 锁，属于行锁）
* **mysql锁的表锁和行锁的对比**：
  * 在加锁效率、锁定粒度以及冲突概率上，表锁肯定是大于行锁的。表锁是锁定了整个表，在加锁期间，无论读写，这个表的数据都是锁定的
  * 行锁只是锁定了这个表中的一条数据，其他数据仍然可以操作，这就可很好的提高了数据库的并发性能。
* **InnoDB的行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件进行数据检索，Innodb才使用行级锁。否则，将使用表锁（锁住索引的所有记录）。这就意味着如果我们的删除/修改语句是没有命中索引的，哪么，则会锁住整个表，这在性能上的影响还是挺大的。**

# 共享锁（S）与排它锁 （X）

| 前/后 | S                                | X        |
| ----- | -------------------------------- | -------- |
| **S** | 不会被锁住                       | 会被锁住 |
| **X** | 可以读历史快照（MVCC多版本控制） | 会被锁住 |
|       |                                  |          |

## 共享锁（S）行锁

又称之为 读 锁，简称 s 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据库，但是只能读不能修改；

加锁方式：

```sql
select * from users where id = 1 lock in share mode;
```

释放方式：

```sql
rollback/commit;
```

## 排它锁 （X）行锁

又称为写锁，简称 X 锁，排它锁不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的锁（包括共享锁和排它锁），只有当前获取了排它锁的事务可以对数据进行读取和修改（**此时其他事务要读取数据可从快照获取（MVCC多版本控制）**）

加锁方式：

```
delete update  insert 默认加排他锁

select * from users where id = 1 for update;
```

释放方式：

```
rollback/commit;
```

# 意向共享锁(IS)和意向排他锁(IX)

当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速的返回，告知该表不能启用表锁，提高了加锁的效率。

## 意向共享锁 表锁

表示事务准备给数据行加入共享锁，也就是说一个数据行在加共享锁之前必须先取得该表的IS锁。

## 意向排他锁 表锁

表示事务准备给数据行加入排它锁，也就是说一个数据行加排它锁之前必须先取得该表的IX锁。

**意向锁是InnoDB数据操作之前自动加的，不需要用户干预**

# 行锁的算法

行锁锁的是索引上的索引项。只有通过索引条件进行数据检索，Innodb才使用性能更高的锁比如：行级锁，临键锁(Next-key lock)，间歇锁（Gap）。否则，将使用表锁（锁住索引的所有记录）

## **临键锁** Next-Key locks

当sql执行按照索引进行数据的检索时，**查询条件为范围查找， 并有数据命中，则加上的锁为Next-Key locks,**锁住索引的记录区间加下一个记录区间，这个区间是左开右闭的

表中存在的数据的id=1，4，7，10，这样其他位置就不存在数据了 

![image-20200501202340800](assets\image-20200501202340800.png)

## **间隙锁** Gap : 当记录不存在时，临键锁退化成Gap

在上述检索条件下，**如果没有命中记录，则退化成间隙锁，锁住数据不存在的区间（左开右开）**

表中存在的数据的id=1，4，7，10，这样其他位置就不存在数据了 

![image-20200501202137047](assets\image-20200501202137047.png)

## **记录锁** Record Lock : 具有唯一性的索引 条件为精准匹配

**具有唯一性的索引才会使用这个锁，比如唯一索引，主键索引，这样在等值操作的时候，锁住的粒度更小，并发性能更好，当然范围的还是会用到上面的 next-key 和 gap**

当SQL执行按照唯一性（Primary Key,Unique Key）索引进行数据的检索时，查询条件等值匹配且查询的数据存在，这时SQL语句上加的锁即为记录锁Record locks,锁住具体的索引项。

![image-20200501202449600](assets\image-20200501202449600.png)

# 哪些情况会加锁呢？

在数据库增删改查四种操作中，insert、delete和update都是会加排它锁(Exclusive Locks)的，而select只有显式声明才会加锁:

- select: **即最常用的查询，是不加任何锁的**
- select ... lock in share mode: 会加共享锁(Shared Locks)
- select ... for update: 会加排它锁